Laborator 1 
===========

Instalati mpi si mpi4py pe calculator.

Compilati programul C din fisierul mpi_hello.c si rulati-l de mai multe ori cu un nr diferit de procesoare:
Ex:

	mpicc mpi_hello.c -o hello
	mpirun -n 4 ./hello
	mpirun -n 20 ./hello

Ce observati? Cate procesoare are in realitate calculatorul pe care rulati (v. /proc/cpuinfo)? 

Rulati programele MPI python pt testarea primitivelor send/recv in varianta blocanta si neblocanta
folosind urmatoarele comenzi:

	mpirun -n 2 python send-recv.py
	mpirun -n 2 python send-recv-nb.py

Apoi rulati cele doua implementari ale problemei de la curs in care intr-o topologie inel (ring)
fiecare procesor trimite un mesaj catre procesorul din dreapta sa (procesorul succesor in ordinea
crescatoare a nr de procesor) si apoi asteapta sa primeasca mesajul de la procesorul predecesor
din inel.

	mpirun -n 4 python test.py
	mpirun -n 4 python test2.py

Ce observati cu privire la cele doua solutii, a propos de cele discutate la curs?
Rulati programele de mai multe ori.

Teme:

1. Barrier

Scrieti un program paralel care sa creeze mai multe procese care se sincronizeaza folosind bariere
in felul urmator:

- procesul zero (root) simuleaza o activitate dormind 4 secunde dupa care scrie un mesaj pe ecran
- toate celelalte procesoare astepta sa termine procesorul zero folosind o bariera, apoi scriu un mesaj
pe ecran avertizand ca se pregatesc de lucru (de fapt se pregatesc de sleep)
- apoi, toate procesoarele simuleaza o activitate aleatoare intre 0 si 10 secunde folosind sleep, iar
dupa terminarea activitatii scriu un mesaj pe ecran

Apoi, toate procesoarele apeleaza rutina Barrier pentru a se sincroniza unele cu altele.

La final, dupa deblocarea din bariera, procesul root conclude ca toate procesele s-au terminat si
scrie un mesaj pe ecran in acest sens.

2. Broadcast

Scrieti un program paralel in care procesul zero (root) foloseste rutina de broadcast pentru a
 trimite un dictionar cu doua chei 

{'key1' : [3, 24.62, 9+4j],
            'key2' : ( 'fmi', 'unibuc')}

catre toate procesele.

Apoi scrieti o versiune care trimite un vector (sa zicem de 10 elemente) in loc de dictionar.

3. Scatter

Scrieti un program paralel in care procesul zero (root) foloseste rutina de distributie personalizata
(scatter) pentru a trimite fiecarui procesor din comunicator un mesaj reprezentand rangul sau plus 1
la patrat:

(rank+1)*(rank+1) in C, sau (rank+1)**2 in python

Fiecare procesor verifica corectitudinea datelor primite (assert) si le afiseaza.

Apoi scrieti o versiune in care in loc sa trimita un scalar celorlalte procesoare, procesorul zero
pregateste o matrice cu un nr de linii egal cu nr de procesoare din comunicator, fiecare linie
continand un vector de 10 elemente, sa zicem, egale cu nr procesorului corespunzator liniei, pe care
o distribuie personalizat catre restul procesoarelor.

4. Gather

Scrieti versiunea inversa a programelor de scatter in care procesorul zero (root) primeste datele
respective de la celelalte procesoare.

